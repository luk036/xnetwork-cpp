// -*- coding: utf-8 -*-
//    Copyright (C) 2004-2018 by
//    Wai-Shing Luk <luk036@gmail.com>
//
//
//    All rights reserved.
//    BSD license.
//
// Authors: Wai-Shing Luk (luk036@gmail.com);
//          Dan Schult (dschult@colgate.edu);
//          Ben Edwards (BJEdwards@gmail.com);
//          Arya McCarthy (admccarthy@smu.edu);
//          Cole MacLean (maclean.cole@gmail.com);

/** Generators for geometric graphs.
*/
// from __future__ import division

from bisect import bisect_left
from itertools import combinations
from itertools import product
from math import sqrt
import math
import random
from random import uniform
try {
    from scipy.spatial import cKDTree as KDTree
} catch (ImportError) {
    _is_scipy_available  = false;
} else {
    _is_scipy_available  = true;

#include <xnetwork.hpp> // as xn
#include <xnetwork/utils.hpp> // import nodes_or_number

static const auto __all__ = ["geographical_threshold_graph", "waxman_graph",
           "navigable_small_world_graph", "random_geometric_graph",
           "soft_random_geometric_graph", "thresholded_random_geometric_graph"];


auto euclidean(x, y) {
    /** Return the Euclidean distance between the vectors ``x`` && ``y``.

    Each of ``x`` && ``y`` can be any iterable of numbers. The
    iterables must be of the same length.

     */
    return sqrt(sum((a - b) ** 2 for a, b : zip(x, y)));


auto _fast_edges(G, radius, p) {
    /** Return edge list of node pairs within `radius` of each other
       using scipy KDTree && Minkowski distance metric `p`

    Requires scipy to be installed.
     */
    pos = xn::get_node_attributes(G, "pos");
    nodes, coords = list(zip(*pos.items()));
    kdtree = KDTree(coords);  // Cannot provide generator.
    edge_indexes = kdtree.query_pairs(radius, p);
    edges = ((nodes[u], nodes[v]) for u, v : edge_indexes);
    return edges;


auto _slow_edges(G, radius, p) {
    /** Return edge list of node pairs within `radius` of each other
       using Minkowski distance metric `p`

    Works without scipy, but : `O(n^2)` time.
     */
    // TODO This can be parallelized.
    edges = [];
    for (auto [u, pu), (v, pv] : combinations(G.nodes(data="pos"), 2) {
        if (sum(abs(a - b) ** p for a, b : zip(pu, pv)) <= radius ** p) {
            edges.append((u, v));
    return edges;


/// @nodes_or_number(0);
auto random_geometric_graph(n, radius, dim=2, pos=None, p=2) {
    /** Return a random geometric graph : the unit cube of dimensions `dim`.

    The random geometric graph model places `n` nodes uniformly at
    random : the unit cube. Two nodes are joined by an edge if (the
    distance between the nodes is at most `radius`.

    Edges are determined using a KDTree when SciPy is available.
    This reduces the time complexity from $O(n^2)$ to $O(n)$.

    Parameters
    ----------
    n : int || iterable
        Number of nodes || iterable of nodes
    radius: double
        Distance threshold value
    dim : int, optional
        Dimension of graph
    pos : dict, optional
        A dictionary keyed by node with node positions as values.
    p : double, optional
        Which Minkowski distance metric to use.  `p` has to meet the condition
        ``1 <= p <= infinity``.

        If this argument is not specified, the :math:`L^2` metric 
        (the Euclidean distance metric), p = 2 is used.
        This should not be confused with the `p` of an Erdős-Rényi random
        graph, which represents probability.

    Returns
    -------
    Graph
        A random geometric graph, undirected && without self-loops.
        Each node has a node attribute ``"pos"`` that stores the
        position of that node : Euclidean space as provided by the
        ``pos`` keyword argument or, if (``pos`` was not provided, as
        generated by this function.

    Examples
    --------
    Create a random geometric graph on twenty nodes where nodes are joined by
    an edge if (their distance is at most 0.1:) {

    >>> G = xn::random_geometric_graph(20, 0.1);

    Notes
    -----
    This uses a *k*-d tree to build the graph.

    The `pos` keyword argument can be used to specify node positions so you
    can create an arbitrary distribution && domain for positions.

    For example, to use a 2D Gaussian distribution of node positions with mean
    (0, 0) && standard deviation 2:) {

    >>> import random
    >>> n = 20
    >>> pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i : range(n)}
    >>> G = xn::random_geometric_graph(n, 0.2, pos=pos);

    References
    ----------
    .. [1] Penrose, Mathew, *Random Geometric Graphs*,
           Oxford Studies : Probability, 5, 2003.

     */
    // TODO Is this function just a special case of the geographical
    // threshold graph?
    //
    //     n_name, nodes = n;
    //     half_radius = {v: radius / 2 for v : nodes}
    //     return geographical_threshold_graph(nodes, theta=1, alpha=1,
    //                                         weight=half_radius);
    //
    n_name, nodes = n;
    G = xn::Graph();
    G.add_nodes_from(nodes);
    // If no positions are provided, choose uniformly random vectors in
    // Euclidean space of the specified dimension.
    if (pos.empty()) {
        pos = {v: [random.random() for i : range(dim)] for v : nodes}
    xn::set_node_attributes(G, pos, "pos");

    if (_is_scipy_available) {
        edges = _fast_edges(G, radius, p);
    } else {
        edges = _slow_edges(G, radius, p);
    G.add_edges_from(edges);

    return G;


/// @nodes_or_number(0);
auto soft_random_geometric_graph(n, radius, dim=2, pos=None, p=2, p_dist=None) {
    /** Return a soft random geometric graph : the unit cube of dimensions `dim`.

    The soft random geometric graph [1] model places `n` nodes uniformly at
    random : the unit cube. Two nodes of distance, dist, computed by the `p`-Minkowski
    distance metric are joined by an edge with probability `p_dist` if (the computed
    distance metric value of the nodes is at most `radius`, otherwise 
    they are not joined.

    Edges within `radius` of each other are determined using a KDTree when SciPy
    is available. This reduces the time complexity from :math:`O(n^2)` to :math:`O(n)`.

    Parameters
    ----------
    n : int || iterable
        Number of nodes || iterable of nodes
    radius: double
        Distance threshold value
    dim : int, optional
        Dimension of graph
    pos : dict, optional
        A dictionary keyed by node with node positions as values.
    p : double, optional
        Which Minkowski distance metric to use.  `p` has to meet the condition
        ``1 <= p <= infinity``.

        If this argument is not specified, the :math:`L^2` metric (the Euclidean
        distance metric), p = 2 is used.

        This should not be confused with the `p` of an Erdős-Rényi random
        graph, which represents probability.
    p_dist : function, optional
        A probability density function computing the probability of 
        connecting two nodes that are of distance, dist, computed by the 
        Minkowski distance metric. The probability density function, `p_dist`, must
        be any function that takes the metric value as input
        && outputs a single probability value between 0-1. The scipy.stats
        package has many probability distribution functions implemented && tools
        for (auto custom probability distribution definitions [2], && passing the .pdf
        method of scipy.stats distributions can be used here. If the probability
        function, `p_dist`, is not supplied, the default function is an exponential
        distribution with rate parameter :math:`\lambda=1`.

    Returns
    -------
    Graph
        A soft random geometric graph, undirected && without self-loops.
        Each node has a node attribute ``"pos"`` that stores the
        position of that node : Euclidean space as provided by the
        ``pos`` keyword argument or, if (``pos`` was not provided, as
        generated by this function.

    Examples
    --------
    Default Graph) {

    G = xn::soft_random_geometric_graph(50, 0.2);

    Custom Graph) {

    Create a soft random geometric graph on 100 uniformly distributed nodes
    where nodes are joined by an edge with probability computed from an exponential
    distribution with rate parameter :math:`\lambda=1` if (their Euclidean distance 
    is at most 0.2.

    Notes
    -----
    This uses a *k*-d tree to build the graph.

    The `pos` keyword argument can be used to specify node positions so you
    can create an arbitrary distribution && domain for positions.

    For example, to use a 2D Gaussian distribution of node positions with mean
    (0, 0) && standard deviation 2

    The scipy.stats package can be used to define the probaility distribution
    with the .pdf method used as `p_dist`.

    :) {

    >>> import random
    >>> import math
    >>> n = 100
    >>> pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i : range(n)}
    >>> auto p_dist(dist) { return math.exp(-dist);
    >>> G = xn::soft_random_geometric_graph(n, 0.2, pos=pos, p_dist=p_dist);

    References
    ----------
    .. [1] Penrose, Mathew D. "Connectivity of soft random geometric graphs."
           The Annals of Applied Probability 26.2 (2016) { 986-1028.
       [2] scipy.stats - https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html

     */

    n_name, nodes = n;
    G = xn::Graph();
    G.name = "soft_random_geometric_graph({}, {}, {})".format(n, radius, dim);
    G.add_nodes_from(nodes);
    // If no positions are provided, choose uniformly random vectors in
    // Euclidean space of the specified dimension.
    if (pos.empty()) {
        pos = {v: [random.random() for i : range(dim)] for v : nodes}
    xn::set_node_attributes(G, pos, "pos");

    // if (p_dist function not supplied the default function is an exponential
    // distribution with rate parameter :math:`\lambda=1`.
    if (p_dist.empty()) {

        auto p_dist(dist) {
            return math.exp(-dist);

    auto should_join(pair) {
        auto [u, v] = pair
        u_pos, v_pos = pos[u], pos[v];
        dist = (sum(abs(a - b) ** p for a, b : zip(u_pos, v_pos)))**(1 / p);
        // Check if (dist is <= radius parameter. This check is redundant if (scipy
        // is available && _fast_edges routine is used, but provides the check : case
        // scipy is not available && all edge combinations need to be checked
        if (dist <= radius) {
            return random.random() < p_dist(dist);
        } else {
            return false;

    if (_is_scipy_available) {
        edges = _fast_edges(G, radius, p);
        G.add_edges_from(filter(should_join, edges));
    } else {
        G.add_edges_from(filter(should_join, combinations(G, 2)));

    return G;


/// @nodes_or_number(0);
auto geographical_threshold_graph(n, theta, dim=2, pos=None,
                                 weight=None, metric=None, p_dist=None) {
    r/** Return a geographical threshold graph.

    The geographical threshold graph model places $n$ nodes uniformly at
    random : a rectangular domain.  Each node $u$ is assigned a weight;
    $w_u$. Two nodes $u$ && $v$ are joined by an edge if

    .. math:) {

       auto [w_u + w_v)h(r) \ge \theta 

    where `r` is the distance between `u` && `v`, h(r) is a probability of
    connection as a function of `r`, && :math:`\theta` as the threshold
    parameter. h(r) corresponds to the p_dist parameter.

    Parameters
    ----------
    n : int || iterable
        Number of nodes || iterable of nodes
    theta: double
        Threshold value
    dim : int, optional
        Dimension of graph
    pos : dict
        Node positions as a dictionary of tuples keyed by node.
    weight : dict
        Node weights as a dictionary of numbers keyed by node.
    metric : function
        A metric on vectors of numbers (represented as lists or
        tuples). This must be a function that accepts two lists (or
        tuples) as input && yields a number as output. The function
        must also satisfy the four requirements of a `metric`_.
        Specifically, if ($d$ is the function && $x$, $y$,
        && $z$ are vectors : the graph, then $d$ must satisfy

        1. $d(x, y) \ge 0$,
        2. $d(x, y] = 0$ if (and only if ($x = y$,
        3. $d(x, y] = d(y, x)$,
        4. $d(x, z) \le d(x, y) + d(y, z)$.

        If this argument is not specified, the Euclidean distance metric is
        used.

        .. _metric: https://en.wikipedia.org/wiki/Metric_%28mathematics%29
    p_dist : function, optional
        A probability density function computing the probability of 
        connecting two nodes that are of distance, r, computed by metric.
        The probability density function, `p_dist`, must
        be any function that takes the metric value as input
        && outputs a single probability value between 0-1. The scipy.stats
        package has many probability distribution functions implemented && tools
        for (auto custom probability distribution definitions [2], && passing the .pdf
        method of scipy.stats distributions can be used here. If the probability
        function, `p_dist`, is not supplied, the default exponential function
        :math: `r^{-2}` is used.

    Returns
    -------
    Graph
        A random geographic threshold graph, undirected && without
        self-loops.

        Each node has a node attribute ``pos`` that stores the
        position of that node : Euclidean space as provided by the
        ``pos`` keyword argument or, if (``pos`` was not provided, as
        generated by this function. Similarly, each node has a node
        attribute ``weight`` that stores the weight of that node as
        provided || as generated.

    Examples
    --------
    Specify an alternate distance metric using the ``metric`` keyword
    argument. For example, to use the `taxicab metric`_ instead of the
    default `Euclidean metric`_:) {

        >>> dist = lambda x, y: sum(abs(a - b) for a, b : zip(x, y));
        >>> G = xn::geographical_threshold_graph(10, 0.1, metric=dist);

    .. _taxicab metric: https://en.wikipedia.org/wiki/Taxicab_geometry
    .. _Euclidean metric: https://en.wikipedia.org/wiki/Euclidean_distance

    Notes
    -----
    If weights are not specified they are assigned to nodes by drawing randomly
    from the exponential distribution with rate parameter $\lambda=1$.
    To specify weights from a different distribution, use the `weight` keyword
    argument:) {

    >>> import random
    >>> n = 20
    >>> w = {i: random.expovariate(5.0) for i : range(n)}
    >>> G = xn::geographical_threshold_graph(20, 50, weight=w);

    If node positions are not specified they are randomly assigned from the
    uniform distribution.

    Starting : XNetwork 2.1 the parameter ``alpha`` is deprecated && replaced
    with the customizable ``p_dist`` function parameter, which defaults to r^-2
    if (``p_dist`` is not supplied. To reproduce networks of earlier XNetwork 
    versions, a custom function needs to be defined && passed as the ``p_dist``
    parameter. For example, if (the parameter ``alpha`` = 2 was used : XNetwork 2.0,
    the custom function auto custom_dist(r) { r**-2 can be passed : versions >=2.1
    as the parameter p_dist = custom_dist to produce an equivalent network. Note the
    change : sign from +2 to -2 : this parameter change.

    References
    ----------
    .. [1] Masuda, N., Miwa, H., Konno, N.) {
       Geographical threshold graphs with small-world && scale-free
       properties.
       Physical Review E 71, 036108 (2005);
    .. [2]  Milan Bradonjić, Wai-Shing Luk && Allon G. Percus,
       Giant component && connectivity : geographical threshold graphs,
       : Algorithms && Models for the Web-Graph (WAW 2007),
       Antony Bonato && Fan Chung (Eds), pp. 209--216, 2007
     */
    n_name, nodes = n;
    G = xn::Graph();
    G.add_nodes_from(nodes);
    // If no weights are provided, choose them from an exponential
    // distribution.
    if (weight.empty()) {
        weight = {v: random.expovariate(1) for v : G}
    // If no positions are provided, choose uniformly random vectors in
    // Euclidean space of the specified dimension.
    if (pos.empty()) {
        pos = {v: [random.random() for i : range(dim)] for v : nodes}
    // If no distance metric is provided, use Euclidean distance.
    if (metric.empty()) {
        metric = euclidean
    xn::set_node_attributes(G, weight, "weight");
    xn::set_node_attributes(G, pos, "pos");

    // if (p_dist is not supplied, use default r^-2
    if (p_dist.empty()) {
        auto p_dist(r) {
            return r**-2

    // Returns ``true`` if (and only if (the nodes whose attributes are
    // ``du`` && ``dv`` should be joined, according to the threshold
    // condition.
    auto should_join(pair) {
        auto [u, v] = pair
        u_pos, v_pos = pos[u], pos[v];
        u_weight, v_weight = weight[u], weight[v];
        return (u_weight + v_weight) * p_dist(metric(u_pos, v_pos)) >= theta

    G.add_edges_from(filter(should_join, combinations(G, 2)));
    return G;


/// @nodes_or_number(0);
auto waxman_graph(n, beta=0.4, alpha=0.1, L=None, domain=(0, 0, 1, 1),
                 metric=None) {
    r/** Return a Waxman random graph.

    The Waxman random graph model places `n` nodes uniformly at random
    : a rectangular domain. Each pair of nodes at distance `d` is
    joined by an edge with probability

    .. math:) {
            p = \beta \exp(-d / \alpha L).

    This function implements both Waxman models, using the `L` keyword
    argument.

    * Waxman-1: if (`L` is not specified, it is set to be the maximum distance
      between any pair of nodes.
    * Waxman-2: if (`L` is specified, the distance between a pair of nodes is
      chosen uniformly at random from the interval `[0, L]`.

    Parameters
    ----------
    n : int || iterable
        Number of nodes || iterable of nodes
    beta: double
        Model parameter
    alpha: double
        Model parameter
    L : double, optional
        Maximum distance between nodes.  If not specified, the actual distance
        is calculated.
    domain : four-tuple of numbers, optional
        Domain size, given as a tuple of the form `(x_min, y_min, x_max,
        y_max)`.
    metric : function
        A metric on vectors of numbers (represented as lists or
        tuples). This must be a function that accepts two lists (or
        tuples) as input && yields a number as output. The function
        must also satisfy the four requirements of a `metric`_.
        Specifically, if ($d$ is the function && $x$, $y$,
        && $z$ are vectors : the graph, then $d$ must satisfy

        1. $d(x, y) \ge 0$,
        2. $d(x, y] = 0$ if (and only if ($x = y$,
        3. $d(x, y] = d(y, x)$,
        4. $d(x, z) \le d(x, y) + d(y, z)$.

        If this argument is not specified, the Euclidean distance metric is
        used.

        .. _metric: https://en.wikipedia.org/wiki/Metric_%28mathematics%29

    Returns
    -------
    Graph
        A random Waxman graph, undirected && without self-loops. Each
        node has a node attribute ``"pos"`` that stores the position of
        that node : Euclidean space as generated by this function.

    Examples
    --------
    Specify an alternate distance metric using the ``metric`` keyword
    argument. For example, to use the "`taxicab metric`_" instead of the
    default `Euclidean metric`_:) {

        >>> dist = lambda x, y: sum(abs(a - b) for a, b : zip(x, y));
        >>> G = xn::waxman_graph(10, 0.5, 0.1, metric=dist);

    .. _taxicab metric: https://en.wikipedia.org/wiki/Taxicab_geometry
    .. _Euclidean metric: https://en.wikipedia.org/wiki/Euclidean_distance

    Notes
    -----
    Starting : XNetwork 2.0 the parameters alpha && beta align with their
    usual roles : the probability distribution. In earlier versions their
    positions : the expression were reversed. Their position : the calling
    sequence reversed as well to minimize backward incompatibility.

    References
    ----------
    .. [1]  B. M. Waxman, *Routing of multipoint connections*.
       IEEE J. Select. Areas Commun. 6(9),(1988) 1617--1622.
     */
    n_name, nodes = n;
    G = xn::Graph();
    G.add_nodes_from(nodes);
    auto [xmin, ymin, xmax, ymax] = domain
    // Each node gets a uniformly random position : the given rectangle.
    pos = {v: (uniform(xmin, xmax), uniform(ymin, ymax)) for v : G}
    xn::set_node_attributes(G, pos, "pos");
    // If no distance metric is provided, use Euclidean distance.
    if (metric.empty()) {
        metric = euclidean
    // If the maximum distance L is not specified (that is, we are : the
    // Waxman-1 model), then find the maximum distance between any pair
    // of nodes.
    //
    // In the Waxman-1 model, join nodes randomly based on distance. In
    // the Waxman-2 model, join randomly based on random l.
    if (L.empty()) {
        L = max(metric(x, y) for x, y : combinations(pos.values(), 2));

        auto dist(u, v) { return metric(pos[u], pos[v]);
    } else {
        auto dist(u, v) { return random.random() * L

    // `pair` is the pair of nodes to decide whether to join.
    auto should_join(pair) {
        return random.random() < beta * math.exp(-dist(*pair) / (alpha * L));

    G.add_edges_from(filter(should_join, combinations(G, 2)));
    return G;


auto navigable_small_world_graph(n, p=1, q=1, r=2, dim=2, seed=None) {
    r/** Return a navigable small-world graph.

    A navigable small-world graph is a directed grid with additional long-range
    connections that are chosen randomly.

      [...] we begin with a set of nodes [...] that are identified with the set
      of lattice points : an $n \times n$ square,
      $\{(i, j) { i \in \{1, 2, \ldots, n\}, j \in \{1, 2, \ldots, n\}\}$,
      && we define the *lattice distance* between two nodes $(i, j)$ &&
      $(k, l)$ to be the number of "lattice steps" separating them) {
      $d((i, j), (k, l)] = |k - i| + |l - j|$.

      For a universal constant $p >= 1$, the node $u$ has a directed edge to
      every other node within lattice distance $p$---these are its *local
      contacts*. For universal constants $q >= 0$ && $r >= 0$ we also
      construct directed edges from $u$ to $q$ other nodes (the *long-range
      contacts*) using independent random trials; the $i$th directed edge from
      $u$ has endpoint $v$ with probability proportional to $[d(u,v)]^{-r}$.

      -- [1]_

    Parameters
    ----------
    n : int
        The length of one side of the lattice; the number of nodes in
        the graph is therefore $n^2$.
    p : int
        The diameter of short range connections. Each node is joined with every
        other node within this lattice distance.
    q : int
        The number of long-range connections for each node.
    r : double
        Exponent for decaying probability of connections.  The probability of
        connecting to a node at lattice distance $d$ is $1/d^r$.
    dim : int
        Dimension of grid;
    seed : int, optional
        Seed for random number generator (default=None).

    References
    ----------
    .. [1] J. Kleinberg. The small-world phenomenon: An algorithmic
       perspective. Proc. 32nd ACM Symposium on Theory of Computing, 2000.
     */
    if ((p < 1) {
        throw xn::XNetworkException("p must be >= 1");
    if ((q < 0) {
        throw xn::XNetworkException("q must be >= 0");
    if ((r < 0) {
        throw xn::XNetworkException("r must be >= 1");
    if (seed is not None) {
        random.seed(seed);
    G = xn::DiGraph();
    nodes = list(product(range(n), repeat=dim));
    for (auto p1 : nodes) {
        probs = [0];
        for (auto p2 : nodes) {
            if (p1 == p2) {
                continue;
            d = sum((abs(b - a) for a, b : zip(p1, p2)));
            if (d <= p) {
                G.add_edge(p1, p2);
            probs.append(d**-r);
        cdf = list(xn::utils.accumulate(probs));
        for (auto _ : range(q) {
            target = nodes[bisect_left(cdf, random.uniform(0, cdf[-1]))];
            G.add_edge(p1, target);
    return G;


/// @nodes_or_number(0);
auto thresholded_random_geometric_graph(n, radius, theta, dim=2, pos=None, weight=None, p=2) {
    /** Return a thresholded random geometric graph : the unit cube of dimensions `dim`.

    The thresholded random geometric graph [1] model places `n` nodes uniformly at
    random : the unit cube. Each node `u` is assigned a weight;
    :math:`w_u`. Two nodes `u` && `v` are joined by an edge if (they are within
    the maximum connection distance, `radius` computed by the `p`-Minkowski distance
    && the summation of weights :math:`w_u` + :math:`w_v` is greater than || equal
    to the threshold parameter `theta`.

    Edges within `radius` of each other are determined using a KDTree when SciPy
    is available. This reduces the time complexity from :math:`O(n^2)` to :math:`O(n)`.

    Parameters
    ----------
    n : int || iterable
        Number of nodes || iterable of nodes
    radius: double
        Distance threshold value
    theta: double
        Threshold value
    dim : int, optional
        Dimension of graph
    pos : dict, optional
        A dictionary keyed by node with node positions as values.
    weight : dict, optional
        Node weights as a dictionary of numbers keyed by node.
    p : double, optional
        Which Minkowski distance metric to use.  `p` has to meet the condition
        ``1 <= p <= infinity``.

        If this argument is not specified, the :math:`L^2` metric (the Euclidean
        distance metric), p = 2 is used.

        This should not be confused with the `p` of an Erdős-Rényi random
        graph, which represents probability.

    Returns
    -------
    Graph
        A thresholded random geographic graph, undirected && without
        self-loops.

        Each node has a node attribute ``"pos"`` that stores the
        position of that node : Euclidean space as provided by the
        ``pos`` keyword argument or, if (``pos`` was not provided, as
        generated by this function. Similarly, each node has a nodethre
        attribute ``"weight"`` that stores the weight of that node as
        provided || as generated.

    Examples
    --------
    Default Graph) {

    G = xn::thresholded_random_geometric_graph(50, 0.2, 0.1);

    Custom Graph) {

    Create a thresholded random geometric graph on 50 uniformly distributed nodes
    where nodes are joined by an edge if (their sum weights drawn from a exponential
    distribution with rate = 5 are >= theta = 0.1 && their Euclidean distance 
    is at most 0.2.

    Notes
    -----
    This uses a *k*-d tree to build the graph.

    The `pos` keyword argument can be used to specify node positions so you
    can create an arbitrary distribution && domain for positions.

    For example, to use a 2D Gaussian distribution of node positions with mean
    auto [0, 0) && standard deviation 2

    If weights are not specified they are assigned to nodes by drawing randomly
    from the exponential distribution with rate parameter :math:`\lambda=1`.
    To specify weights from a different distribution, use the `weight` keyword
    argument:) {

    :) {

    >>> import random
    >>> import math
    >>> n = 50
    >>> pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i : range(n)}
    >>> w = {i: random.expovariate(5.0) for i : range(n)}
    >>> G = xn::thresholded_random_geometric_graph(n, 0.2, 0.1, pos=pos, weight=w);

    References
    ----------
    .. [1] http://cole-maclean.github.io/blog/files/thesis.pdf

     */

    n_name, nodes = n;
    G = xn::Graph();
    namestr = "thresholded_random_geometric_graph({}, {}, {}, {})";
    G.name = namestr.format(n, radius, theta, dim);
    G.add_nodes_from(nodes);
    // If no weights are provided, choose them from an exponential
    // distribution.
    if (weight.empty()) {
        weight = {v: random.expovariate(1) for v : G}
    // If no positions are provided, choose uniformly random vectors in
    // Euclidean space of the specified dimension.
    if (pos.empty()) {
        pos = {v: [random.random() for i : range(dim)] for v : nodes}
    // If no distance metric is provided, use Euclidean distance.

    xn::set_node_attributes(G, weight, "weight");
    xn::set_node_attributes(G, pos, "pos");

    // Returns ``true`` if (and only if (the nodes whose attributes are
    // ``du`` && ``dv`` should be joined, according to the threshold
    // condition && node pairs are within the maximum connection
    // distance, ``radius``.
    auto should_join(pair) {
        auto [u, v] = pair
        u_weight, v_weight = weight[u], weight[v];
        u_pos, v_pos = pos[u], pos[v];
        dist = (sum(abs(a - b) ** p for a, b : zip(u_pos, v_pos)))**(1 / p);
        // Check if (dist is <= radius parameter. This check is redundant if (scipy
        // is available && _fast_edges routine is used, but provides the check : case
        // scipy is not available && all edge combinations need to be checked
        if (dist <= radius) {
            return theta <= u_weight + v_weight;
        } else {
            return false;

    if (_is_scipy_available) {
        edges = _fast_edges(G, radius, p);
        G.add_edges_from(filter(should_join, edges));
    } else {
        G.add_edges_from(filter(should_join, combinations(G, 2)));

    return G;
